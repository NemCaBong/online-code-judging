--
-- PostgreSQL database dump
--

-- Dumped from database version 16.2 (Debian 16.2-1.pgdg120+2)
-- Dumped by pg_dump version 16.2 (Debian 16.2-1.pgdg120+2)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: challenge_details; Type: TABLE DATA; Schema: public; Owner: judge0
--

COPY public.challenge_details (id, language_id, boilerplate_code, challenge_id) FROM stdin;
8	71	def two_sum(nums, target):\\n    \\n# DO NOT TOUCH\\nif __name__ == "__main__":\\n    n = int(input().strip())\\n\\n    nums = list(map(int, input().strip().split()))\\n\\n    target = int(input().strip())\\n\\n    result = two_sum(nums, target)\\n\\n    if result:\\n        print(result[0], result[1])\\n    else:\\n        print("No solution found")\\n\n	7
11	63	/**\\n * Plus One Algorithm: Adds one to a number represented as an array of digits.\\n * @param {number[]} digits Array of digits representing a number\\n * @returns {string} Resulting number after adding one\\n */\\nconst plusOne = (digits) => {\\n    \\n};\\n\\n// DO NOT TOUCH\\nconst processInput = () => {\\n  let input = \\"\\";\\n  process.stdin.on(\\"data\\", (chunk) => {\\n    input += chunk;\\n  });\\n  process.stdin.on(\\"end\\", () => {\\n    const lines = input.trim().split(\\"\\\\n\\");\\n    const n = parseInt(lines[0], 10);\\n    const digits = lines[1].trim().split(\\" \\").map(Number);\\n    const result = plusOne(digits);\\n    console.log(result.join(\\" \\"));\\n  });\\n};\\nprocessInput();\\n\\n	10
7	54	#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nvector<int> twoSum(const vector<int>& nums, int target) {\\n\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> nums(n);\\n    \\n    for (int i = 0; i < n; i++) {\\n        cin >> nums[i];\\n    }\\n\\n    int target;\\n    cin >> target;\\n\\n    vector<int> result = twoSum(nums, target);\\n    if (!result.empty()) {\\n        cout << result[0] << " " << result[1] << endl;\\n    } else {\\n        cout << "No solution found" << endl;\\n    }\\n\\n    return 0;\\n}\\n\n	7
6	62	import java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Scanner;\\n\\npublic class TwoSum {\\n    public static int[] twoSum(int[] nums, int target) {\\n       \\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        int n = Integer.parseInt(scanner.nextLine().trim()); // Read the number of elements (if needed)\\n        String[] numStrings = scanner.nextLine().split(" ");\\n        int[] nums = new int[numStrings.length];\\n        \\n        for (int i = 0; i < numStrings.length; i++) {\\n            nums[i] = Integer.parseInt(numStrings[i]);\\n        }\\n\\n        int target = Integer.parseInt(scanner.nextLine().trim());\\n\\n        int[] result = twoSum(nums, target);\\n        if (result.length > 0) {\\n            System.out.println(result[0] + " " + result[1]);\\n        } else {\\n            System.out.println("No solution found");\\n        }\\n\\n        scanner.close();\\n    }\\n}\\n\\n\n	7
12	63	const isValid = (s) => {\\n    const stack = [];\\n    const map = {\\n        '(': ')',\\n        '{': '}',\\n        '[': ']'\\n    };\\n    for (let i = 0; i < s.length; i++) {\\n        const char = s[i];\\n        if (map[char]) {\\n            stack.push(char);\\n        } else {\\n            const last = stack.pop();\\n            if (map[last] !== char) {\\n                return false;\\n            }\\n        }\\n    }\\n    return stack.length === 0;\\n};\\n\\n// DO NOT TOUCH\\nconst processInput = () => {\\n    let input = \\"\\";\\n    process.stdin.on(\\"data\\", (chunk) => {\\n        input += chunk;\\n    });\\n\\n    process.stdin.on(\\"end\\", () => {\\n        const lines = input.trim().split(\\"\\\\n\\");\\n        const n = parseInt(lines[0], 10);\\n        const parentheses = lines[1].trim().split(\\" \\").join(\\"\\");\\n        const isValidResult = isValid(parentheses) ? 1 : 0;\\n        console.log(isValidResult);\\n    });\\n};\\nprocessInput();\\n	4
10	63	function findMedianSortedArrays(nums1, nums2) {\\n    const merged = [...nums1, ...nums2].sort((a, b) => a - b);\\n    const mid = Math.floor(merged.length / 2);\\n    \\n    if (merged.length % 2 === 0) {\\n        return (merged[mid - 1] + merged[mid]) / 2;\\n    } else {\\n        return merged[mid];\\n    }\\n}\\n\\n// DO NOT TOUCH\\nfunction processInput() {\\n    const input = [];\\n    process.stdin.on(\\"data\\", (chunk) => input.push(chunk));\\n    process.stdin.on(\\"end\\", () => {\\n    const data = input.join(\\"\\").trim().split(\\"\\\\n\\");\\n    const nums1 = data[1].trim()\\n      ? data[1].trim().split(/\\\\s+/).map(Number)\\n      : [];\\n    const nums2 = data[3].trim()\\n      ? data[3].trim().split(/\\\\s+/).map(Number)\\n      : [];\\n    const result = findMedianSortedArrays(nums1, nums2);\\n    console.log(result.toFixed(5));\\n    });\\n}\\nprocessInput();\\n	2
1	63	function twoSum(nums, target) {\\n\\n}\\n\\n// DO NOT TOUCH\\nfunction processInput(input) {\\n    const lines = input.trim().split('\\\\n');\\n    const n = parseInt(lines[0]);\\n    const nums = lines[1].split(' ').map(Number);\\n    const target = parseInt(lines[2]);\\n\\n    return { n, nums, target };\\n}\\n\\n\\nlet input = '';\\nprocess.stdin.on('data', (data) => {\\n    input += data;\\n});\\n\\nprocess.stdin.on('end', () => {\\n    const { nums, target } = processInput(input);\\n    const result = twoSum(nums, target);\\n    if (result.length <= 0) {\\n        console.log(-1);\\n    } else {\\n        console.log(result.join(' '));\\n    }\\n});\\n\\n\\n	7
9	63	const maxSubArray = (nums) => {\\n    let result = nums[0];\\n    let previousEnd = nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n        previousEnd = Math.max(previousEnd + nums[i], nums[i]);\\n        result = Math.max(result, previousEnd);\\n    }\\n    return result;\\n};\\n\\n// Hàm xử lý chính\\nconst main = () => {\\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\\\n');\\n    const nums = input[1].split(' ').map(Number);\\n    console.log(maxSubArray(nums));\\n};\\n\\nmain();\\n	1
\.


--
-- Data for Name: challenges; Type: TABLE DATA; Schema: public; Owner: judge0
--

COPY public.challenges (id, name, description, slug, is_deleted, difficulty, accepted_results, total_attempts, space_limit, created_at, updated_at, time_limit) FROM stdin;
3	Trapping Rain Water	Given `n` non-negative integers representing an elevation map where the width of each bar is 1, calculate how much water it can trap after raining.\n\n---\n\n## Examples\n\n### Example 1\n\n![Rainwater Trap Example](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\n- **Input:** `height = [0,1,0,2,1,0,1,3,2,1,2,1]`\n- **Output:** `6`\n- **Explanation:** The above elevation map (black section) is represented by the array `[0,1,0,2,1,0,1,3,2,1,2,1]`. In this case, `6` units of rainwater (blue section) are being trapped.\n\n### Example 2\n\n- **Input:** `height = [4,2,0,3,2,5]`\n- **Output:** `9`\n\n---\n\n## Constraints\n\n- `n == height.length`\n- `1 <= n <= 2 * 10^4`\n- `0 <= height[i] <= 10^5`\n	trapping-rain-water	f	HARD	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
2	Median of Two Sorted Arrays	Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the **median** of the two sorted arrays.\n\nThe solution should have an **O(log (m+n))** runtime complexity.\n\n## Examples\n\n### Example 1\n\n- **Input:** `nums1 = [1,3]`, `nums2 = [2]`\n- **Output:** `2.00000`\n- **Explanation:** Merging the arrays results in `[1,2,3]`, and the median is `2`.\n\n### Example 2\n\n- **Input:** `nums1 = [1,2]`, `nums2 = [3,4]`\n- **Output:** `2.50000`\n- **Explanation:** Merging the arrays results in `[1,2,3,4]`, and the median is calculated as `(2 + 3) / 2 = 2.5`.\n\n## Constraints\n\n- `nums1.length == m`\n- `nums2.length == n`\n- `0 <= m <= 1000`\n- `0 <= n <= 1000`\n- `1 <= m + n <= 2000`\n- `-10^6 <= nums1[i], nums2[i] <= 10^6`\n	median-of-two-sorted-arrays	f	HARD	2	7	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
1	Maximum Subarray	Given an integer array `nums`, find the **subarray** with the largest sum, and return its sum.\n\n## Examples\n\n### Example 1\n\n- **Input:** `nums = [-2,1,-3,4,-1,2,1,-5,4]`\n- **Output:** `6`\n- **Explanation:** The subarray `[4, -1, 2, 1]` has the largest sum `6`.\n\n### Example 2\n\n- **Input:** `nums = [1]`\n- **Output:** `1`\n- **Explanation:** The subarray `[1]` has the largest sum `1`.\n\n### Example 3\n\n- **Input:** `nums = [5,4,-1,7,8]`\n- **Output:** `23`\n- **Explanation:** The subarray `[5, 4, -1, 7, 8]` has the largest sum `23`.\n\n## Constraints\n\n- `1 <= nums.length <= 10^5`\n- `-10^4 <= nums[i] <= 10^4`\n\n## Follow Up:\n\nIf you have figured out the O(n) solution, try coding another solution using the **divide and conquer approach**, which is more subtle.	maximum-subarray	f	MEDIUM	2	4	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
9	Find the Index of the First Occurrence in a String	Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.\n\n### Examples\n\n#### Example 1\n\n- **Input:** \n  - `haystack = "sadbutsad"`\n  - `needle = "sad"`\n- **Output:** `0`\n- **Explanation:** "sad" occurs at index `0` and `6`. The first occurrence is at index `0`, so we return `0`.\n\n#### Example 2\n\n- **Input:** \n  - `haystack = "leetcode"`\n  - `needle = "leeto"`\n- **Output:** `-1`\n- **Explanation:** "leeto" did not occur in "leetcode", so we return `-1`.\n\n### Constraints\n\n- `1 <= haystack.length, needle.length <= 10^4`\n- `haystack` and `needle` consist of only lowercase English characters.\n	find-the-first-occurrence-of-a-substring	f	EASY	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
10	Plus One	You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n\n### Task\n\nIncrement the large integer by one and return the resulting array of digits.\n\n### Examples\n\n#### Example 1\n\n- **Input:**\n  - `digits = [1,2,3]`\n- **Output:** \n  - `[1,2,4]`\n- **Explanation:** The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be `[1,2,4]`.\n\n#### Example 2\n\n- **Input:** \n  - `digits = [4,3,2,1]`\n- **Output:** \n  - `[4,3,2,2]`\n- **Explanation:** The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be `[4,3,2,2]`.\n\n#### Example 3\n\n- **Input:** \n  - `digits = [9]`\n- **Output:** \n  - `[1,0]`\n- **Explanation:** The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be `[1,0]`.\n\n### Constraints\n\n- `1 <= digits.length <= 100`\n- `0 <= digits[i] <= 9`\n- `digits` does not contain any leading 0's.\n	plus-one	f	EASY	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:44.448528	1.00
8	3Sum	Given an integer array `nums`, return all the **triplets** `[nums[i], nums[j], nums[k]]` such that:\n- `i != j`, `i != k`, and `j != k`\n- `nums[i] + nums[j] + nums[k] == 0`\n\nThe solution set must **not contain duplicate triplets**.\n\n---\n\n## Examples\n\n### Example 1\n\n- **Input:** `nums = [-1,0,1,2,-1,-4]`\n- **Output:** `[[-1,-1,2],[-1,0,1]]`\n- **Explanation:**\n  - `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0`\n  - `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0`\n  - `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0`\n  - The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.\n  - The order of the output and the order of the triplets does not matter.\n\n### Example 2\n\n- **Input:** `nums = [0,1,1]`\n- **Output:** `[]`\n- **Explanation:** The only possible triplet does not sum up to `0`.\n\n### Example 3\n\n- **Input:** `nums = [0,0,0]`\n- **Output:** `[[0,0,0]]`\n- **Explanation:** The only possible triplet sums up to `0`.\n\n---\n\n## Constraints\n\n- `3 <= nums.length <= 3000`\n- `-10^5 <= nums[i] <= 10^5`\n	3sum	f	MEDIUM	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
6	Longest Palindromic Substring	Given a string `s`, return the **longest palindromic substring** in `s`.\n\n---\n\n## Examples\n\n### Example 1\n\n- **Input:** `s = "babad"`\n- **Output:** `"bab"`\n- **Explanation:** `"aba"` is also a valid answer.\n\n### Example 2\n\n- **Input:** `s = "cbbd"`\n- **Output:** `"bb"`\n\n---\n\n## Constraints\n\n- `1 <= s.length <= 1000`\n- `s` consists of only digits and English letters.\n	longest-palindromic-substring	f	MEDIUM	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
5	Arithmetic Subarrays	A sequence of numbers is called **arithmetic** if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence `s` is arithmetic if and only if `s[i+1] - s[i] == s[1] - s[0]` for all valid `i`.\n\nFor example, these are arithmetic sequences:\n- `1, 3, 5, 7, 9`\n- `7, 7, 7, 7`\n- `3, -1, -5, -9`\n\nThe following sequence is **not** arithmetic:\n- `1, 1, 2, 5, 7`\n\nYou are given an array of `n` integers, `nums`, and two arrays of `m` integers each, `l` and `r`, representing `m` range queries, where the `i`th query is the range `[l[i], r[i]]`. All the arrays are 0-indexed.\n\nReturn a list of boolean elements `answer`, where `answer[i]` is `true` if the subarray `nums[l[i]], nums[l[i]+1], ... , nums[r[i]]` can be rearranged to form an arithmetic sequence, and `false` otherwise.\n\n### Examples\n\n#### Example 1\n- **Input:** `nums = [4,6,5,9,3,7]`, `l = [0,0,2]`, `r = [2,3,5]`\n- **Output:** `[true, false, true]`\n- **Explanation:**\n  - In the 0th query, the subarray is `[4,6,5]`. This can be rearranged as `[6,5,4]`, which is an arithmetic sequence.\n  - In the 1st query, the subarray is `[4,6,5,9]`. This cannot be rearranged as an arithmetic sequence.\n  - In the 2nd query, the subarray is `[5,9,3,7]`. This can be rearranged as `[3,5,7,9]`, which is an arithmetic sequence.\n\n#### Example 2\n- **Input:** `nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10]`, `l = [0,1,6,4,8,7]`, `r = [4,4,9,7,9,10]`\n- **Output:** `[false, true, false, false, true, true]`\n\n### Constraints\n- `n == nums.length`\n- `m == l.length`\n- `m == r.length`\n- \\(2 \\leq n \\leq 500\\)\n- \\(1 \\leq m \\leq 500\\)\n- \\(0 \\leq l[i] < r[i] < n\\)\n- \\(-10^5 \\leq nums[i] \\leq 10^5\\)\n	arithmetic-subarrays	f	MEDIUM	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
4	Valid Parentheses	Given a string `s` containing just the characters `(`, `)`, `{`, `}`, `[`, and `]`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\n## Examples\n\n### Example 1\n\n- **Input:** `s = "()"`\n- **Output:** `true`\n\n### Example 2\n\n- **Input:** `s = "()[]{}"`\n- **Output:** `true`\n\n### Example 3\n\n- **Input:** `s = "(]"`\n- **Output:** `false`\n\n### Example 4\n\n- **Input:** `s = "([])"`\n- **Output:** `true`\n\n## Constraints\n\n- `1 <= s.length <= 10^4`\n- `s` consists of parentheses only `()[]{}`	valid-parentheses	f	EASY	0	0	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
7	Two Sum	Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n### Conditions\n- Each input has exactly one solution.\n- You may not use the same element twice.\n- You can return the answer in any order.\n\n### Approach\nA common approach to solve this problem efficiently is by using a hash map to store each number's index as we iterate through the array. For each number, we check if the difference between the target and the current number already exists in the hash map. This approach allows us to achieve a time complexity of \\( O(n) \\).\n\n### Examples\n\n#### Example 1\n- **Input:** \n  - `nums = [2,7,11,15]`\n  - `target = 9`\n- **Output:** \n  - `[0,1]`\n- **Explanation:** Because `nums[0] + nums[1] == 9`, we return `[0, 1]`.\n\n#### Example 2\n- **Input:** \n  - `nums = [3,2,4]`\n  - `target = 6`\n- **Output:** \n  - `[1,2]`\n- **Explanation:** `nums[1] + nums[2] == 6`, so we return `[1, 2]`.\n\n#### Example 3\n- **Input:** \n  - `nums = [3,3]`\n  - `target = 6`\n- **Output:** \n  - `[0,1]`\n- **Explanation:** `nums[0] + nums[1] == 6`, so we return `[0, 1]`.\n\n### Constraints\n- $$2 \\leq \\text{nums.length} \\leq 10^4$$\n- $$-10^9 \\leq \\text{nums[i]} \\leq 10^9$$\n- $$-10^9 \\leq \\text{target} \\leq 10^9$$\n- Only one valid answer exists.\n\n\n### Follow-up\nCan you come up with an algorithm that is less than \\( O(n^2) \\) time complexity? \n\nUsing a hash map (dictionary) reduces the time complexity to \\( O(n) \\) by storing and looking up values in constant time.\n	two-sum	f	EASY	13	36	50000	2024-10-13 08:05:44.448528	2024-10-13 08:05:48.323375	1.00
\.


--
-- Name: challenge_details_id_seq; Type: SEQUENCE SET; Schema: public; Owner: judge0
--

SELECT pg_catalog.setval('public.challenge_details_id_seq', 12, true);


--
-- Name: challenges_id_seq; Type: SEQUENCE SET; Schema: public; Owner: judge0
--

SELECT pg_catalog.setval('public.challenges_id_seq', 60, true);


--
-- PostgreSQL database dump complete
--

